<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redisson的watchdog机制是怎么样的？</title>
    <url>/2023/11/17/Redisson%E7%9A%84watchdog%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<p>为了避免Redis实现的分布式锁超时，Redisson中引入了watch dog的机制，他可以帮助我们在Redisson实例被关闭前，不断的延长锁的有效期。</p>
<p>自动续租：当一个Redisson客户端实例获取到一个分布式锁时，如果没有指定锁的超时时间，Watchdog会基于Netty的时间轮启动一个后台任务，定期向Redis发送命令，重新设置锁的过期时间，通常是锁的租约时间的1&#x2F;3。这确保了即使客户端处理时间较长，所持有的锁也不会过期。<br>续期时长：默认情况下，每10s钟做一次续期，续期时长是30s。<br>停止续期：当锁被释放或者客户端实例被关闭时，Watchdog会自动停止对应锁的续租任务。</p>
<p>在Redisson中，watch dog的主要实现在<a href="https://github.com/redisson/redisson/blob/master/redisson/src/main/java/org/redisson/RedissonBaseLock.java#L155">scheduleExpirationRenewal</a>方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void scheduleExpirationRenewal(long threadId) &#123;</span><br><span class="line">    ExpirationEntry entry = new ExpirationEntry();</span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    if (oldEntry != null) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        try &#123;</span><br><span class="line">            renewExpiration();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                cancelExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定时任务执行续期</span><br><span class="line">private void renewExpiration() &#123;</span><br><span class="line">    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    if (ee == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Timeout task = getServiceManager().newTimeout(new TimerTask() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            if (ent == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Long threadId = ent.getFirstThreadId();</span><br><span class="line">            if (threadId == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">                if (e != null) &#123;</span><br><span class="line">                    log.error(&quot;Can&#x27;t update lock &#123;&#125; expiration&quot;, getRawName(), e);</span><br><span class="line">                    EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (res) &#123;</span><br><span class="line">                    // reschedule itself</span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cancelExpirationRenewal(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);</span><br><span class="line">    </span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用LUA脚本，进行续期</span><br><span class="line">protected CompletionStage&lt;Boolean&gt; renewExpirationAsync(long threadId) &#123;</span><br><span class="line">    return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return 1; &quot; +</span><br><span class="line">                    &quot;end; &quot; +</span><br><span class="line">                    &quot;return 0;&quot;,</span><br><span class="line">            Collections.singletonList(getRawName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，上面的代码的主要逻辑就是用了一个TimerTask来实现了一个定时任务，设置了internalLockLeaseTime &#x2F; 3的时长进行一次锁续期。默认的超时时长是30s，那么他会每10s进行一次续期，通过LUA脚本进行续期，再续30s</p>
<p>不过，这个续期也不是无脑续，他也是有条件的，其中ExpirationEntry ent &#x3D; EXPIRATION_RENEWAL_MAP.get(getEntryName());这个值得我们关注，他会从EXPIRATION_RENEWAL_MAP中尝试获取一个KV对，如果查不到，就不续期了。</p>
<p>EXPIRATION_RENEWAL_MAP这个东西，会在unlock的时候操作的，对他进行remove，所以一个锁如果被解了，那么就不会再继续续期了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void unlock() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        get(unlockAsync(Thread.currentThread().getId()));</span><br><span class="line">    &#125; catch (RedisException e) &#123;</span><br><span class="line">        if (e.getCause() instanceof IllegalMonitorStateException) &#123;</span><br><span class="line">            throw (IllegalMonitorStateException) e.getCause();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public RFuture&lt;Void&gt; unlockAsync(long threadId) &#123;</span><br><span class="line">    return getServiceManager().execute(() -&gt; unlockAsync0(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private RFuture&lt;Void&gt; unlockAsync0(long threadId) &#123;</span><br><span class="line">    CompletionStage&lt;Boolean&gt; future = unlockInnerAsync(threadId);</span><br><span class="line">    CompletionStage&lt;Void&gt; f = future.handle((opStatus, e) -&gt; &#123;</span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line"></span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            if (e instanceof CompletionException) &#123;</span><br><span class="line">                throw (CompletionException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new CompletionException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (opStatus == null) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = new IllegalMonitorStateException(&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span><br><span class="line">                    + id + &quot; thread-id: &quot; + threadId);</span><br><span class="line">            throw new CompletionException(cause);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return new CompletableFutureWrapper&lt;&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void cancelExpirationRenewal(Long threadId) &#123;</span><br><span class="line">    ExpirationEntry task = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (threadId != null) &#123;</span><br><span class="line">        task.removeThreadId(threadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (threadId == null || task.hasNoThreads()) &#123;</span><br><span class="line">        Timeout timeout = task.getTimeout();</span><br><span class="line">        if (timeout != null) &#123;</span><br><span class="line">            timeout.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，第4行-&gt;16行-&gt;22行-&gt;57行。就是一次unlock过程中，对EXPIRATION_RENEWAL_MAP进行移除，进而取消下一次锁续期的实现细节。</p>
<p>并且在unlockAsync方法中，不管unlockInnerAsync是否执行成功，还是抛了异常，都不影响cancelExpirationRenewal的执行，也可以理解为，只要unlock方法被调用了，即使解锁未成功，那么也可以停止下一次的锁续期。</p>
<p><strong>什么情况会进行续期</strong></p>
<p>当我们使用Redisson创建一个分布式锁的时候，并不是所有情况都会续期的，我们可以看下以下加锁过程的代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private RFuture&lt;Long&gt; tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) &#123;</span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture;</span><br><span class="line">    if (leaseTime &gt; 0) &#123;</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,</span><br><span class="line">                TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletionStage&lt;Long&gt; s = handleNoSync(threadId, ttlRemainingFuture);</span><br><span class="line">    ttlRemainingFuture = new CompletableFutureWrapper&lt;&gt;(s);</span><br><span class="line"></span><br><span class="line">    CompletionStage&lt;Long&gt; f = ttlRemainingFuture.thenApply(ttlRemaining -&gt; &#123;</span><br><span class="line">        // lock acquired</span><br><span class="line">        if (ttlRemaining == null) &#123;</span><br><span class="line">            if (leaseTime &gt; 0) &#123;</span><br><span class="line">                internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                scheduleExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ttlRemaining;</span><br><span class="line">    &#125;);</span><br><span class="line">    return new CompletableFutureWrapper&lt;&gt;(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>什么情况会停止续期</strong></p>
<p>如果一个锁的unlock方法被调用了，那么就会停止续期。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void cancelExpirationRenewal(Long threadId) &#123;</span><br><span class="line">    ExpirationEntry task = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    if (task == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (threadId != null) &#123;</span><br><span class="line">        task.removeThreadId(threadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (threadId == null || task.hasNoThreads()) &#123;</span><br><span class="line">        Timeout timeout = task.getTimeout();</span><br><span class="line">        if (timeout != null) &#123;</span><br><span class="line">            timeout.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是通过EXPIRATION_RENEWAL_MAP.remove来做的。那么cancelExpirationRenewal还有下面一处调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void scheduleExpirationRenewal(long threadId) &#123;</span><br><span class="line">    ExpirationEntry entry = new ExpirationEntry();</span><br><span class="line">    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);</span><br><span class="line">    if (oldEntry != null) &#123;</span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        try &#123;</span><br><span class="line">            renewExpiration();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                cancelExpirationRenewal(threadId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在尝试开启续期的过程中，如果线程被中断了，那么就会取消续期动作了。</p>
<p>目前，Redisson是没有针对最大续期次数和最大续期时间的支持的。所以，正常情况下，如果没有解锁，是会一直续期下去的。</p>
<p>但是需要注意的是，Redisson的续期是Netty的时间轮（TimerTask、Timeout、Timer）的，并且操作都是基于JVM的，所以，当应用宕机、下线或者重启后，续期任务就没有了。这样也能在一定程度上避免机器挂了但是锁一直不释放导致的死锁问题。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Safepoint安全点理解</title>
    <url>/2023/06/02/Safepoint%E5%AE%89%E5%85%A8%E7%82%B9%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="安全点定义"><a href="#安全点定义" class="headerlink" title="安全点定义"></a>安全点定义</h2><p>​	Safepoint 可以理解成是在代码执行过程中的一些特殊位置，当线程执行到这些位置的时候，线程可以暂停。在 SafePoint 保存了其他位置没有的一些当前线程的运行信息，供其他线程读取。这些信息包括：线程上下文的任何信息，例如对象或者非对象的内部指针等等。我们一般这么理解 SafePoint，就是线程只有运行到了 SafePoint 的位置，他的一切状态信息，才是确定的，也只有这个时候，才知道这个线程用了哪些内存，没有用哪些；并且，只有线程处于 SafePoint 位置，这时候对 JVM的堆栈信息进行修改，例如回收某一部分不用的内存，线程才会感知到，之后继续运行，每个线程都有一份自己的内存使用快照，这时候其他线程对于内存使用的修改，线程就不知道了，只有再进行到 SafePoint 的时候，才会感知。</p>
<h2 id="什么时候会进入Safepoint"><a href="#什么时候会进入Safepoint" class="headerlink" title="什么时候会进入Safepoint"></a>什么时候会进入Safepoint</h2><p>​	当VM Thread需要做vm 操作时会让线程进入安全点，vm操作类型有很多，可以参考<code>VM_OP_ENUM</code>源码 vmOperations.hpp。下面是几种经常发生的进入Safepoint的情形：</p>
<ol>
<li>GC：由于需要每个线程的对象使用信息，以及回收一些对象，释放某些堆内存或者直接内存，所以需要 进入Safepoint来 Stop the world；</li>
<li>定时进入 SafePoint：每经过<code>-XX:GuaranteedSafepointInterval</code> 配置的时间，都会让所有线程进入 Safepoint，一旦所有线程都进入，立刻从 Safepoint 恢复。这个定时主要是为了一些没必要立刻 Stop the world 的任务执行，可以设置<code>-XX:GuaranteedSafepointInterval=0</code>关闭这个定时。</li>
<li>由于 jstack，jmap 和 jstat 等命令，会导致 Stop the world：这种命令都需要采集堆栈信息，所以需要所有线程进入 Safepoint 并暂停。</li>
<li>偏向锁取消：锁大部分情况是没有竞争的（某个同步块大多数情况都不会出现多线程同时竞争锁），所以可以通过偏向来提高性能。即在无竞争时，之前获得锁的线程再次获得锁时，会判断是否偏向锁指向我，那么该线程将不用再次获得锁，直接就可以进入同步块。但是高并发的情况下，偏向锁会经常失效，导致需要取消偏向锁，取消偏向锁的时候，需要 Stop the world，因为要获取每个线程使用锁的状态以及运行状态。</li>
<li>Java Instrument 导致的 Agent 加载以及类的重定义：由于涉及到类重定义，需要修改栈上和这个类相关的信息，所以需要 Stop the world</li>
<li>Java Code Cache相关：当发生 JIT 编译优化或者去优化，需要 OSR 或者 Bailout 或者清理代码缓存的时候，由于需要读取线程执行的方法以及改变线程执行的方法，所以需要 Stop the world</li>
</ol>
<h2 id="避免Safepoint副作用"><a href="#避免Safepoint副作用" class="headerlink" title="避免Safepoint副作用"></a>避免Safepoint副作用</h2><p>​	Safepoint在一定程度上是可以理解成是为了让所有用户线程停顿（Stop The World）而设计的。STW对应用系统来说是一件很可怕的事情，JVM不论是在GC还是在其他的VM操作上都在努力避免STW和减少STW时间。</p>
<p><strong>安全点最主要的副作用就是可能导致STW时间过长，应该极力避免这点副作用。</strong></p>
<p>​	对第一个进入安全点的线程来说，STW是从它进入安全点开始的，如果有某个线程一直无法进入安全点就会导致进入安全点的时间一直处于等待状态，进而导致STW的时间过长。所以，应避免线程执行过长无法进入安全点的情况。</p>
<p>​	可数循环体内执行时间过长以及JIT优化导致无法进入安全点的问题是最常见的无法进入安全点的情况。在写大循环的时候可以把循环索引值数据类型定义成long。</p>
<p>​	在高并发应用中，偏向锁并不能带来性能提升，反而因为偏向锁取消带来了很多没必要的某些线程进入安全点 。所以建议关闭：<code>-XX:-UseBiasedLocking</code>。</p>
<p>​	jstack，jmap 和 jstat 等命令，也会导致进入安全点。所以，生产环境应该关闭Thead dump的开关，避免dump时间过长导致应用STW时间过长。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Safepoint</tag>
      </tags>
  </entry>
  <entry>
    <title>Young GC过于频繁</title>
    <url>/2023/03/13/Young-GC%E8%BF%87%E4%BA%8E%E9%A2%91%E7%B9%81/</url>
    <content><![CDATA[<h2 id="背景知识-background"><a href="#背景知识-background" class="headerlink" title="背景知识 (background)"></a>背景知识 (background)</h2><p>Young GC过于频繁，主要有以下影响：</p>
<p>GC线程消耗的CPU时间过多，容易触发Linux CFS 限制进程的CPU<br>虽然单次GC停顿较短，但频次高了之后，整个服务的吞吐量会下降<br>GC过于频繁，慢请求产生的临时对象经过几轮YoungGC后容易晋升到老年代<br>目前YoungGC一分钟超过60次，则会触发报警，建议控制在20次&#x2F;分钟以内。</p>
<h2 id="查看指标-dashboard"><a href="#查看指标-dashboard" class="headerlink" title="查看指标 (dashboard)"></a>查看指标 (dashboard)</h2><p>展开: JVM &#x2F; 内存 &#x2F; GC &#x2F; ClassLoader这一行，找到监控面板：GC耗时 和 GC原因与频次。</p>
<p><img src="/2023/03/13/Young-GC%E8%BF%87%E4%BA%8E%E9%A2%91%E7%B9%81/image-20231013105605631.png" alt="image-20231013105605631"></p>
<h2 id="止损措施-action"><a href="#止损措施-action" class="headerlink" title="止损措施 (action)"></a>止损措施 (action)</h2><p>Young GC频繁，通常不用立即处理，大多需要优化代码。</p>
<p>不同物理机的配置、性能各异，若因CPU限制导致长尾请求集中在某个节点上，可先摘流。</p>
<p>事后改进(postmortem)<br>Young GC过于频繁，说明JVM内存分配压力大，可能是Young区比较小或者代码加载到内存的数据过多。</p>
<p>可参考原因部分，优化代码，调整GC参数。</p>
<p>尽量一次调整一个GC参数，灰度观察，排除干扰数据</p>
<h2 id="可能的原因-cause"><a href="#可能的原因-cause" class="headerlink" title="可能的原因 (cause)"></a>可能的原因 (cause)</h2><p>YoungGC频繁一般是内存问题，在优化代码降低频率的同时，也需关注某个时间段的累计耗时。总的来说，在CPU Quota允许的范围内，GC总耗时越少越好，GC频率反倒不是那么重要。</p>
<p>一、Eden区过小<br>g1 newSizePercent</p>
<p>二. 大批量加载数据。</p>
<p>三. 内存分配速率过高</p>
<p>代码原因导致的数据加载过多，常见于：</p>
<ol>
<li>文件上传下载、报表导入导出</li>
<li>数据量随业务发展突增，代码没有分页或没有限制分页大小，或部分请求参数组合导致返回了大量数据</li>
<li>业务逻辑涉及的内存全量加载到内存里计算，不复用中间结果，相同的数据重复请求</li>
<li>Redis缓存了大List，导致序列化&#x2F;反序列化临时对象过多</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal内存泄露问题</title>
    <url>/2023/05/13/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>ThreadLocal是java.lang下面的一个类，是用来解决java多线程程序中并发问题的一种途径；通过为每一个线程创建一份共享变量的副本来保证各个线程之间的变量的访问和修改互相不影响；</p>
<p>ThreadLocal存放的值是线程内共享的，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递，这样处理后，能够优雅的解决一些实际问题。</p>
<p>比如一次用户的页面操作请求，我们可以在最开始的filter中，把用户的信息保存在ThreadLocal中，在同一次请求中，在使用到用户信息，就可以直接到ThreadLocal中获取就可以了。</p>
<p>ThreadLocal有四个方法，分别为：<br>●initialValue<br>返回此线程局部变量的初始值<br>●get<br>返回此线程局部变量的当前线程副本中的值。如果这是线程第一次调用该方法，则创建并初始化此副本。<br>●set<br>将此线程局部变量的当前线程副本中的值设置为指定值。许多应用程序不需要这项功能，它们只依赖于 initialValue() 方法来设置线程局部变量的值。<br>●remove<br>移除此线程局部变量的值。</p>
<h2 id="ThreadLocal的实现原理"><a href="#ThreadLocal的实现原理" class="headerlink" title="ThreadLocal的实现原理"></a>ThreadLocal的实现原理</h2><p>ThreadLocal当中用于保存线程的独有变量的数据结构是一个内部类：ThreadLocalMap，也是k-v结构。<br>key就是当前的ThreadLoacal对象，而v就是我们想要保存的值。</p>
<p><img src="/2023/05/13/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/image-20231013144555156.png" alt="image-20231013144555156"></p>
<p>上图中基本描述出了Thread、ThreadLocalMap以及ThreadLocal三者之间的包含关系。</p>
<p>Thread类对象中维护了ThreadLocalMap成员变量，而ThreadLocalMap维护了以ThreadLocal为key，需要存储的数据为value的Entry数组。</p>
<h2 id="ThreadLocal内存泄露问题"><a href="#ThreadLocal内存泄露问题" class="headerlink" title="ThreadLocal内存泄露问题"></a>ThreadLocal内存泄露问题</h2><p>ThreadLocal对象中是有两个引用的，一个是栈上的ThreadLocal引用，一个是ThreadLocalMap中的Key对他的引用。那么栈上的ThreadLocal引用不在使用了，即方法结束后这个对象引用就不再用了，那么，ThreadLocal对象因为还有一条引用链在，所以就会导致他无法被回收，久而久之可能就会对导致OOM。</p>
<p>这就是我们所说的ThreadLocal的内存泄露问题，为了解决这个问题，ThreadLocalMap使用了弱引用。如果用了弱引用，那么ThreadLocal对象就可以在下次GC的时候被回收掉了。</p>
<p><img src="/2023/05/13/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/image-20231013144809878.png" alt="image-20231013144809878"></p>
<p>当一个线程调用ThreadLocal的set方法设置变量的时候，当前线程的ThreadLocalMap就会存放一个记录，这个记录的键为ThreadLocal的弱引用，value就是通过set设置的值，这个value值被强引用。</p>
<p>这样做可以很大程度上的避免因为ThreadLocal的使用而导致的OOM问题，但是这个问题却无法彻底避免。</p>
<p>因为我们可以看到，虽然key是弱引用，但是value的那条引用，还是个强引用呢！而且他的生命周期是和Thread一样的，也就是说，只要这个Thread还在， 这个对象就无法被回收。</p>
<p>那么，什么情况下，Thread会一直在呢？那就是线程池。</p>
<p>在线程池中，重复利用线程的时候，就会导致这个引用一直在，而value就一直无法被回收。</p>
<p>那如何解决呢？</p>
<p>ThreadLocalMap底层使用数组来保存元素，使用“线性探测法”来解决hash冲突的，在每次调用ThreadLocal的get、set、remove等方法的时候，内部会实际调用ThreadLocalMap的get、set、remove等操作。</p>
<p>而ThreadLocalMap的每次get、set、remove，都会清理过期的Entry。</p>
<p>所以，当我们在一个ThreadLocal用完之后，手动调用一下remove，就可以在下一次GC的时候，把Entry清理掉。</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用中 error: pathspec ‘xxx‘ did not match any file(s) known to git 报错解决方法</title>
    <url>/2022/01/03/git%E4%BD%BF%E7%94%A8%E4%B8%AD-error-pathspec-%E2%80%98xxx%E2%80%98-did-not-match-any-file-s-known-to-git-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>项目上想合并代码，以自己的分支master作为主分支，要合并分支study，结果<br>在 git merge study 的时候报如下错误<br>其实在 git checkout 的时候也会出现这个错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: pathspec &#x27;origin/XXX&#x27; did not match any file(s) known to git.</span><br><span class="line">发现是本地git没有识别到远程git仓库的分支</span><br></pre></td></tr></table></figure>

<h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><p>1、首先看下所有分支 是否有新分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>2、如果没看到，那么执行以下操作，这步是获取所有分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>


<p>执行完会看到这样提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Enumerating objects: 4, done.</span><br><span class="line">remote: Counting objects: 100% (4/4), done.</span><br><span class="line">Unpacking objects: 100% (4/4), 1.06 KiB | 90.00 KiB/s, done.</span><br><span class="line">From codeup.aliyun.com:5eeb0689892c58bb7c394ab5/pxb/pxb-fronted</span><br><span class="line"> * [new branch]      XXX -&gt; origin/XXX</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3、切换到远程分支:</p>
<p>git checkout origin&#x2F;xxx</p>
<p>提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Note: switching to &#x27;origin/xxx&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">Turn off this advice by setting config variable advice.detachedHead to false</span><br><span class="line"></span><br><span class="line">HEAD is now at dc877cd XXX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、现在可以看到自己的分支是一串数字字母，这时新建并切换到分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure>

<p>5、现在需要跟远程的分支进行关联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -u origin/xxx</span><br></pre></td></tr></table></figure>

<p>6、这时我们执行git pull来看看什么反馈:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用CompletableFuture完成并发编排，提升接口性能</title>
    <url>/2023/07/26/%E4%BD%BF%E7%94%A8CompletableFuture%E5%AE%8C%E6%88%90%E5%B9%B6%E5%8F%91%E7%BC%96%E6%8E%92%EF%BC%8C%E6%8F%90%E5%8D%87%E6%8E%A5%E5%8F%A3%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>我的项目中，有这样一个场景，我们要发起一个用户主动还款之后，需要把在途的扣款单全部暂停，但是因为用户选择还款单据可能比较多，而且暂停是调用外部资金打款系统的接口实现的，这个地方如果一条一条执行就很慢，但是如果起多线程执行的话，我就没办法知道他们每一个暂定的返回结果。</p>
<p>我想可以实现一个这样的功能：多线程去执行暂停动作，如果都成功了，那么就推进我的主动扣款后续流程，如果暂停有任何一个接口调用失败了，那么先不推进后续流程，等下次重试。</p>
<p> 技术选型 </p>
<p>为了实现这个功能，我了解到CompletableFuture，他是Java 8中引入的一个新特性，它提供了一种简单的方法来实现异步编程和任务组合。</p>
<p>他的多线程编排的能力刚好可以用在我这个场景中，而且他底层是基于ForkJoinPool实现的，所以他的性能也比较高效，所以最终我选择了这个方案。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//异步暂停扣款</span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(noticeDetails.stream()</span><br><span class="line">        .map(detail -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            pause(detail);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;)).toArray(CompletableFuture[]::new));</span><br><span class="line"></span><br><span class="line">//所有暂停扣款成功后，更新代还通知单</span><br><span class="line">allFutures.whenComplete((v, e) -&gt; &#123;</span><br><span class="line">    if (e == null) &#123;</span><br><span class="line">        //执行后续的还款操作</span><br><span class="line">        //...</span><br><span class="line">        //...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.error(&quot;notice failed&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="得到结果"><a href="#得到结果" class="headerlink" title="得到结果"></a>得到结果</h4><p>在用了CompletableFuture做编排之前，原来50笔订单的暂停扣款，需要大概10s左右，但是用了CompletableFuture之后，50笔订单的暂停扣款只需要1秒钟左右。</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>双亲委派企业级应用</title>
    <url>/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JDBC-SPI"><a href="#JDBC-SPI" class="headerlink" title="JDBC-SPI"></a>JDBC-SPI</h1><h2 id="打破背景"><a href="#打破背景" class="headerlink" title="打破背景"></a>打破背景</h2><p>为了更加灵活的连接数据库，我们的JDK定义了<code>Driver</code>接口，需要与数据库进行连接的包必须实现该接口。例如：MySQL，建议去观察下项目中<code>mysql-connector</code>包，下面就有实现类的全限定类名。  </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011142644308-1697011108741.png" alt="image-20231011142644308"></p>
<h2 id="打破原因"><a href="#打破原因" class="headerlink" title="打破原因"></a>打破原因</h2><p>在上述背景下，执行 <code>DriverManager</code>类的方法时，需要去加载实现类。还记得我们第一篇文章讲的 <code>BootStrapClassLoader</code>吗，它只能加载<code>rt.jar</code>下的类。而MySQL的加载路径隶属于<code>AppClassLoader</code>,所以理论上它压根就不能被加载。</p>
<p>于是线程上下文类加载器就应运而生，由于<code>ThreadClassLoader</code>一般情况下&#x3D;&#x3D;<code>AppClassLoader</code>。于是通过线程上下文类加载器加载JDBC实现类，打破了双亲委派模型，顺利实现功能。</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><ol>
<li><p>查看DriverManager类 </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011142230230-1697011108742.png" alt="image-20231011142230230"></p>
</li>
<li><p>获取线程上下文加载器，一般是AppClassLoder，并且Set到ServiceLoader中 </p>
</li>
<li><p>通过迭代器迭代<img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011142323580-1697011108742.png" alt="image-20231011142323580"></p>
</li>
<li><p>获取实现类路径配置 &#x3D; “META-INF&#x2F;services&#x2F;“ + service.name; </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011142340932-1697011108742.png" alt="image-20231011142340932"></p>
</li>
<li><p>加载实现类 </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011142704289-1697011108742.png" alt="image-20231011142704289"></p>
</li>
</ol>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>ServiceLoader只提供了遍历的方式来获取目标实现类，假如有多个JDBC实现类，都会去加载，没有提供按需加载的方法。像<code>Dubbo SPI</code>就提供了可配置化的加载.</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="打破背景-1"><a href="#打破背景-1" class="headerlink" title="打破背景"></a>打破背景</h2><p>Tomcat能将多个WebApp应用在一个容器内启动。</p>
<h2 id="打破原因-1"><a href="#打破原因-1" class="headerlink" title="打破原因"></a>打破原因</h2><ol>
<li>Tomcat下有多个WebApp,但它只有一个JVM。不同的WebApp可能会依赖同一个第三方类库的不同版本，因此要保证每个应用程序的类库都是独立的，保证相互隔离。</li>
<li>部署在同一个Tomcat容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。</li>
<li>web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 总结：有些共用类只需要一份，有些类只需要多份隔离。</li>
</ol>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231010110449075-1697009246437-1697011108742.png" alt="image-20231010110449075"></p>
<ol>
<li>Webapp 应用类加载器每个应用在部署后，都会创建一个唯一的类加载器。该类加载器会加载位于 WEB-INF&#x2F;lib下的jar文件中的class 和 WEB-INF&#x2F;classes下的class文件。</li>
<li>通过<code>Common ClassLoader</code>加载通用的类。</li>
<li>通过 <code>Catalina ClassLoader</code> 加载Tomcat自身需要的类。</li>
</ol>
<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="打破背景-2"><a href="#打破背景-2" class="headerlink" title="打破背景"></a>打破背景</h2><p><code>SpringBoot</code>为了jar包结构的简洁,创建了与普通jar包不一样的包格式</p>
<h2 id="打破原因-2"><a href="#打破原因-2" class="headerlink" title="打破原因"></a>打破原因</h2><p>jar文件规范中，一个jar文件如果要运行必须将入口类放置到jar文件的顶层目录，这样才能被正确的加载。</p>
<h2 id="查看源码方法"><a href="#查看源码方法" class="headerlink" title="查看源码方法"></a>查看源码方法</h2><p>单纯的SpringBoot项目你找不到启动类的，看这个链接:<a href="https://link.juejin.cn/?target=https://www.cnblogs.com/fengpinglangjingruma/p/13916297.html">点它 </a>。</p>
<h2 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li><p>当<code>java -jar xxx</code>时，会去调用<code>JarLauncher.launch()</code>方法。</p>
</li>
<li><p>获取需要加载的类和包并作为参数传递到LauncherURLClassLoader </p>
</li>
<li><p>创建类加载器 </p>
</li>
<li><p>获取启动类, 可以看到在我们的项目中Start-Class &#x3D; “Application.class” </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011153254352-1697011108742.png" alt="image-20231011153254352"> </p>
</li>
<li><p>通过自定义加载器加载类，并且反射调用 <code>Start-Class</code>的<code>main</code>方法启动项目。 </p>
<p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011153237491-1697011108742.png" alt="image-20231011153237491"></p>
</li>
</ol>
<h1 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h1><h2 id="打破背景-3"><a href="#打破背景-3" class="headerlink" title="打破背景"></a>打破背景</h2><p>早期的项目，如果修改了代码之后，需要重启项目才能使代码正确运行。</p>
<h2 id="打破原因-3"><a href="#打破原因-3" class="headerlink" title="打破原因"></a>打破原因</h2><p>为了让代码修改后能够快速响应，需要通过热加载的形式，动态发现修改的类，并且使用自定义类加载器快速加载变化的类。</p>
<h2 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h2><p><img src="/2022/01/10/%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/image-20231011162414744.png" alt="image-20231011162414744"></p>
<h1 id="Jar包冲突"><a href="#Jar包冲突" class="headerlink" title="Jar包冲突"></a>Jar包冲突</h1><h2 id="打破背景-4"><a href="#打破背景-4" class="headerlink" title="打破背景"></a>打破背景</h2><p>项目中经常出现jar包冲突导致抛出异常，不是NoSuchMethod,NoClassDefund。</p>
<h2 id="打破原因-4"><a href="#打破原因-4" class="headerlink" title="打破原因"></a>打破原因</h2><p>Jar包冲突的原因是使用了C2类的方法, 但JVM却加载了C1类。可以让相同包名的包由不同的类加载器加载，进行隔离，避免jar包冲突。</p>
<h2 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h2><ol>
<li><p>通过自定义类加载器，为每个中间件自定义一个加载器，这些加载器之间的关系是平行的，彼此没有依赖关系。</p>
</li>
<li><p>这样每个中间件的classloader就可以加载各自版本的包。因为一个类的全限定名以及加载该类的加载器两者共同形成了这个类在JVM中的惟一标识。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线上问题FullGC</title>
    <url>/2023/06/11/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98FullGC/</url>
    <content><![CDATA[<h2 id="背景知识-background"><a href="#背景知识-background" class="headerlink" title="背景知识 (background)"></a>背景知识 (background)</h2><p>​	FullGC通常伴随着比较久的停顿和性能退化，不过不同GC算法关注点不一样。</p>
<p>​	对CMS来说，FullGC是比较正常的，每次STW也比较短，但频繁的话会导致吞吐量下降，因此重点考察CMS FullGC的频率，目前1分钟超过12次就报警。</p>
<p>​	CMS分两种模式：Background和Foreground，严格来说，Foreground才算FullGC。Foreground在Promotion Failed、Concurrent Mode Failure等条件下触发，是单线程串行回收的，对整个老年代进行清理、压缩，消除内存碎片，STW 时间长，有时会长达十几秒。Background是正常情况下触发的并发回收的 CMS GC，停顿非常短，对业务影响很小。</p>
<p>​	对G1来说，FullGC对整个堆(Young+Old Generation)进行清理，通常意味着更大的停顿时长，是我们要竭力避免的，因此出现一次就报警。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FullGC报警是针对老年代的GC频率，我们有单独的GC耗时报警用于捕捉停顿较久的场景。</span><br></pre></td></tr></table></figure>

<h3 id="查看指标-dashboard"><a href="#查看指标-dashboard" class="headerlink" title="查看指标 (dashboard)"></a>查看指标 (dashboard)</h3><p>展开: JVM &#x2F; 内存 &#x2F; GC &#x2F; <a href="https://so.csdn.net/so/search?q=ClassLoader&spm=1001.2101.3001.7020">ClassLoader</a>这一行，找到监控面板：GC耗时和 GC原因与频次。</p>
<p><img src="/2023/06/11/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98FullGC/image-20231011192636268.png" alt="image-20231011192636268"></p>
<h3 id="止损措施-action"><a href="#止损措施-action" class="headerlink" title="止损措施 (action)"></a>止损措施 (action)</h3><p>FullGC发生时，已产生负面影响。如果集中在单个节点，可考虑摘流或者调小节点权重。</p>
<p>建议关注Old区的增长，在下次FullGC前，<code>先手动摘流，然后Dump堆内存</code>。</p>
<h3 id="事后改进-postmortem"><a href="#事后改进-postmortem" class="headerlink" title="事后改进(postmortem)"></a>事后改进(postmortem)</h3><p>FullGC通常是老年代内存不足，放不下新晋升的对象。</p>
<p>大概率是代码的内存开销太大，比如全量或大批量加载数据、导入导出&#x2F;上传下载等。</p>
<p>可通过慢接口、慢查询、AccessLog 、 应用日志等初步筛选可疑接口，优化逻辑，确保单次执行的资源开销是稳定的、高效的。</p>
<p>除此之外，请参考原因(cause)部分，针对当前业务调优GC参数，建议每次只调整一个变量，灰度观察。</p>
<p>GC优化后，通过所选时段内累计GC耗时计算GC耗时在所选时段内的占比是否下降，所选时段内累计GC次数查看所选时段内各类型GC的次数是否有变化。优先GC耗时下降，GC频率仅做参考。</p>
<h2 id="可能的原因-cause"><a href="#可能的原因-cause" class="headerlink" title="可能的原因 (cause)"></a>可能的原因 (cause)</h2><p>Old区通常是是生命周期比较久的对象，比如本地缓存、各种连接池的连接、监控指标、全局对象等。</p>
<p>处理这种问题，可在Old区GC前后分别Dump内存(先摘流)，借助MAT进行内存&#x2F;对象Diff，按照对象、类、类加载器、包等多个维度观察 Histogram，分析 Unreachable。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unreachable是可回收的对象，可用于判断某些对象是否生成过多。</span><br></pre></td></tr></table></figure>

<h4 id="一、过早晋升-Premature-Promotion"><a href="#一、过早晋升-Premature-Promotion" class="headerlink" title="一、过早晋升(Premature Promotion)"></a>一、过早晋升(Premature Promotion)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过早晋升通常以CMS+Parnew组合居多，G1的话，建议勿指定新生代大小(-Xmn)。</span><br></pre></td></tr></table></figure>

<p>​	临时对象经过几次 Young GC后才会晋升到 Old 区，每复制到survivor区一次， GC Age 就会增长 1，最大Age通过 -XX:MaxTenuringThreshold 来控制。</p>
<p>过早晋升一般不会直接影响 GC，常伴随着浮动垃圾、大对象担保失败等问题，我们通过以下方式交叉验证：</p>
<p>JVM内存池里的指标Old Gen(heap)经过一次GC回收后，内存占用下降了很多，可比较 max &#x2F; min，比如，max 值为 2.5G ，GC后只剩下了 500 M，那说明，只有500MB活跃对象，其余的都被回收了。<br>GC 内存分配里新生代每秒增加的字节(申请的内存)过大，同时有很多对象晋升到了老年代(每秒新增字节)。老年代晋升的越多，就可能有过早晋升的问题。<br>查看节点的GC日志，查看对象晋升的threshold，类似new threshold 1(max 6)，说明只回收了一次就晋升了。<br>过早晋升，会增加Old区的内存占用，触发频繁的Full GC，降低吞吐量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Old区占用超过某个阈值(+XX:CMSInitiatingOccupancyFraction/+XX:InitiatingHeapOccupancyPercent)时，CMS会触发 Background GC，G1会触发mixed gc。</span><br></pre></td></tr></table></figure>

<p>​	常见原因是新生代(Young&#x2F;Eden区)过小，Young区被快速填满，本该回收的对象参与了 GC并晋升。另外，无法及时回收的对象还会影响-XX:MaxTenuringThreshold的动态计算，导致 threshold 变小 ，更多的临时对象进入了 Old 区，造成资源浪费。</p>
<p>JVM内存池里的指标Eden Gen(heap)的max即 Young区的最大值，可适当调大观察效果。</p>
<p>若在总的Heap内存不变的情况下调大Young区，可适当调小Old区，但考虑到浮动垃圾，建议Old区大小为一轮回收后Old区活跃对象的3倍左右。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意，调大Young区对ParNew来说每次GC Copy的对象更多了，虽然会降低GC次数，但可能增加单次GC耗时，可参考所选时段总耗时来决定优化是否有效。</span><br></pre></td></tr></table></figure>

<p>除了Young区小之外，也可能是内存分配压力大，可通过<code>JVM / 内存 / GC / ClassLoader</code>里的GC内存分配面板来验证。</p>
<p><img src="/2023/06/11/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98FullGC/image-20231011192908088.png" alt="image-20231011192908088"></p>
<p>内存分配速率，如果是偶发的毛刺、突增，通常是业务代码加载了大批数据，可配合MAT等工具分析内存、优化代码；如果持续比较大，那说明内存不够用了，只能申请套餐扩容或者尝试G1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发可筛选时间段内的慢请求、AccessLog、应用日志，缩小排查范围；尽可能保证接口内存开销的稳定性，避免浪费资源。</span><br></pre></td></tr></table></figure>

<p>内存分配速率越大，GC越频繁，两次 Young GC 的间隔时间尽量大于接口P99.9的时间，这样尽量让对象在 Young 区就被回收，可以减少很多停顿。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">慢请求不只是对线程池/资源池的挤占，在多次GC期间不能被回收的垃圾就转移到Old区了。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>引入分布式锁解决并发问题</title>
    <url>/2023/07/31/%E5%BC%95%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>我的项目中，有一个场景会出现并发问题，就是我们有一个支付单，这个支付单会有到期的自动关闭，以及用户也可以主动取消订单进行关闭。</p>
<p>这两个操作，有的时候就会出现并发的问题，导致重复关单，重复发消息给下游，导致下游处理失败。</p>
<p>为了解决这个并发的问题，我在项目中采用了分布式锁来解决。</p>
<h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h4><p>其实分布式锁有很多种方案，无非就是借助一个第三方的系统，来做互斥性的协调。那么市面上主流的实现方式就是基于数据库、zookeeper以及redis。</p>
<p>我在选型的时候分别了解了一下这几个方案。</p>
<p>其实最简单的肯定是数据库的方式，在数据库中建一张表，加锁时创建一条记录，解锁时再把记录删除，通过唯一性约束来避免重复的记录。当要加锁的时候，判断下数据库中是否已经有这条记录了，没有就插入一条。</p>
<p>这个方案的话好处就是实现简单，缺点也比较明显，就是太依赖数据库，在高并发情况下，可能会对数据库造成压力，并且性能也不太好，而且也会占用很多数据库链接，影响正常的业务。</p>
<p>基于数据库的悲观锁当然也可以实现，但是悲观锁的机制，可能会导致锁表，也会导致线程阻塞的问题，所以这个方案我也放弃了。</p>
<p>另外在zookeeper和redis中，我选择了redis，因为redis我们现在系统中已经在用了，但是zk的话我们没有引入，并且搭建一个zk集群成本也挺高的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在redis中呢，我们最开始使用了setnx的方案，但是后来经常会出现并发问题，后来发现是因为有的时候，我们设置的解锁的超时时间太短了，导致锁提前释放了。但是拉长超时时间又会使得接口的吞吐量降低，后来我发现redisson其实他实现了看门狗的机制，可以帮助我们做自动续期，我就选了redisson的方案。</span><br></pre></td></tr></table></figure>

<p>但是，其实现在我们这个方案也存在一定的问题，那就是在redis的主节点如果出现问题的情况下，可能会导致锁丢失，但是因为我们这个目前业务量还没有那么大，所以暂时还没有遇到这个问题，不过我也了解过，其实可以基于redlock来解决这个问题，redlock可以借助集群的投票机制，超过半数以上写入成功才算加锁成功，这样可解决单点故障的问题。后面会考虑优化一下。</p>
<h4 id="得到的结果"><a href="#得到的结果" class="headerlink" title="得到的结果"></a>得到的结果</h4><p>解决了并发的问题</p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo + Typora 图片上传问题</title>
    <url>/2022/01/02/%E8%A7%A3%E5%86%B3hexo-Typora-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文解决hexo + <a href="https://so.csdn.net/so/search?q=Typora&spm=1001.2101.3001.7020">Typora</a>图片上传不显示的问题</p>
<p>按如下步骤修改设定Typora中图片放置的位置</p>
<p>这样当自己新建一个文章后，如果添加图片，会在文章所在目录下生成一个与文章同名的文件夹，并将图片存入该文件夹中，此后该文章中所有添加的图片均存入该文件夹中。</p>
<p><img src="/2022/01/02/%E8%A7%A3%E5%86%B3hexo-Typora-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/image-20231011190708925.png" alt="image-20231011190708925"></p>
<p>修改博客根目录下的_config.yml文件中的post_asset_folder字段设置为true</p>
<p>当设置 post_asset_folder 参数后，在hexo n命令建立文件时， 会自动建立一个与文章同名的文件夹，把与该文章相关的所有图片资源都放到此文件夹内，这样就可以方便的使用图片资源</p>
<p>同时，只有当post_asset_folder设置为true后，后续安装的插件才会起作用</p>
<p><img src="/2022/01/02/%E8%A7%A3%E5%86%B3hexo-Typora-%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E9%97%AE%E9%A2%98/image-20231011190829534.png" alt="image-20231011190829534"></p>
<p>安装插件</p>
<p>到博客的根目录下执行 npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> –save 命令来进行插件的安装</p>
<p>当文章全部写完后，使用Typora的替换功能（替换功能包含删除功能，当替换的内容什么都不输入时为全部删除）将所有图片地址前面多余的部分删除即可</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
