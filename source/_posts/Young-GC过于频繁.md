---
title: Young GC过于频繁
date: 2023-03-13 10:54:29
tags:
- GC
categories:
- JVM
---

## 背景知识 (background)

Young GC过于频繁，主要有以下影响：

GC线程消耗的CPU时间过多，容易触发Linux CFS 限制进程的CPU
虽然单次GC停顿较短，但频次高了之后，整个服务的吞吐量会下降
GC过于频繁，慢请求产生的临时对象经过几轮YoungGC后容易晋升到老年代
目前YoungGC一分钟超过60次，则会触发报警，建议控制在20次/分钟以内。

## 查看指标 (dashboard)

展开: JVM / 内存 / GC / ClassLoader这一行，找到监控面板：GC耗时 和 GC原因与频次。

![image-20231013105605631](Young-GC%E8%BF%87%E4%BA%8E%E9%A2%91%E7%B9%81/image-20231013105605631.png)

## 止损措施 (action)

Young GC频繁，通常不用立即处理，大多需要优化代码。

不同物理机的配置、性能各异，若因CPU限制导致长尾请求集中在某个节点上，可先摘流。

事后改进(postmortem)
Young GC过于频繁，说明JVM内存分配压力大，可能是Young区比较小或者代码加载到内存的数据过多。

可参考原因部分，优化代码，调整GC参数。

尽量一次调整一个GC参数，灰度观察，排除干扰数据

## 可能的原因 (cause)

YoungGC频繁一般是内存问题，在优化代码降低频率的同时，也需关注某个时间段的累计耗时。总的来说，在CPU Quota允许的范围内，GC总耗时越少越好，GC频率反倒不是那么重要。

一、Eden区过小
g1 newSizePercent

二. 大批量加载数据。

三. 内存分配速率过高

代码原因导致的数据加载过多，常见于：

1. 文件上传下载、报表导入导出
2. 数据量随业务发展突增，代码没有分页或没有限制分页大小，或部分请求参数组合导致返回了大量数据
3. 业务逻辑涉及的内存全量加载到内存里计算，不复用中间结果，相同的数据重复请求
4. Redis缓存了大List，导致序列化/反序列化临时对象过多
   